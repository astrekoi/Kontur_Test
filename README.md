
<h1 align="center"> A. Известный художник</h1>  
<h3 align="center">ограничение по времени на тест 1 секунда</h3>  
<h3 align="center">ограничение по памяти на тест 256 мегабайт  </h3>  
<h3 align="center">ввод: стандартный ввод</h3>  
<h3 align="center">вывод: стандартный вывод  </h3>
 

Очень известный в определенных кругах художник Игнат рисовал каждый день по одной картине в течение N дней. В i-й день Игнат нарисовал картину с яркостью красок ai. Теперь Игнат хочет выбрать из N получившихся картин самую контрастную пару. Пара картин (i,j), нарисованных в дни i и j соответственно, называется самой контрастной, если значение ai−aj максимально среди всех возможных пар.

**Входные данные**  
В первой строке содержится целое число N  — количество дней (2≤N≤10^5). Во второй строке содержатся целые числа a1,a2,...,aN, где ai — яркость картины, нарисованной в i-й день (−10^9 ≤ ai ≤ 10^9).

**Выходные данные**  
Выведите различные целые числа i и j — номера дней, в которые Игнат нарисовал самую контрастную пару картин (i,j). Числа i и j должны лежать в пределах от 1 до N. Если таких пар несколько, выведите пару с максимальным значением i−j. Обратите внимание, что пара (i,j) отличается от пары (j,i).

**Система оценки**  
В этой задаче 2 группы тестов.

* Первая группа тестов стоит 5 баллов, для нее выполняется ограничение N≤1000.
* Вторая группа тестов стоит 5 баллов, для нее выполняется ограничение N≤105.

Входные данные
```
6
1 2 1 3 1 3
```
Выходные данные
```
6 1
```

Входные данные
```
4
2 1 0 -1
```
Выходные данные
```
1 4
```

<details>
  <summary>Решение на C#</summary>

```C#
using System;
using System.Linq;

class Program
{
    static void Main(string[] args)
    {
        int n = int.Parse(Console.ReadLine());
        int[] a = Console.ReadLine().Split().Select(int.Parse).ToArray();
        int max = a.Max();
        int min = a.Min();
        int maxIndex = Array.LastIndexOf(a, max) + 1;
        int minIndex = Array.IndexOf(a, min) + 1;
        Console.WriteLine($"{maxIndex} {minIndex}");
    }
}
```
</details>

---
<h1 align="center"> B. Коллекционер </h1>  
<h3 align="center">ограничение по времени на тест 1 секунда</h3>  
<h3 align="center">ограничение по памяти на тест 256 мегабайт  </h3>  
<h3 align="center">ввод: стандартный ввод</h3>  
<h3 align="center">вывод: стандартный вывод  </h3>
 

Игнат увлекается коллекционированием настенных ковров. Недавно он смог освободить одну стену комнаты и теперь хочет повесить на эту стену ковер наибольшей возможной площади. В стену вбито N гвоздей. Ковер можно вешать только параллельно осям координат, на четыре гвоздя, расположенных по углам ковра. Другие гвозди на стене разрешается накрывать ковром. 

Найдите максимальную площадь ковра, который можно повесить на эту стену.

**Входные данные**  
В первой строке содержится целое число N — количество забитых гвоздей в стене (4≤N≤1500). В каждой из следующих N строк содержатся целые числа xi и yi — координаты i-го гвоздя (−109≤xi,yi≤109). Гарантируется, что никакие два гвоздя не расположены в одной точке.

**Выходные данные**  
Выведите максимальную площадь ковра, который можно разместить на стене. Если на стене невозможно разместить ни одного ковра, выведите 0. Обратите внимание, что ответ задачи может не помещаться в 32-битный целый тип данных!

**Система оценки**  
В этой задаче 3 группы тестов.

* Первая группа тестов стоит 4 балла, для нее выполняется ограничение N≤30.
* Вторая группа тестов стоит 3 балла, для нее выполняется ограничение N≤300.
* Третья группа тестов стоит 3 балла, для нее выполняется ограничение N≤1500.

Входные данные
```
8
0 0
1 1
0 2
5 0
5 2
0 4
3 0
3 4
```
Выходные данные
```
12
```

Входные данные
```
 4
 1  -1
 1   1
-1   1
 1   0
```
Выходные данные
```
0
```

_Примечание:_  
В первом тесте можно повесить ковер с площадью 12 на гвозди с координатами (0,0), (3,0), (0,4), (3,4) либо ковер с площадью 10 на гвозди с координатами (0,0), (5,0), (0,2), (5,2).

<details>
  <summary>Решение на Java</summary>
  
```java
import java.util.*;
    
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] x = new int[n];
        int[] y = new int[n];
        for (int i = 0; i < n; i++) {
            x[i] = sc.nextInt();
            y[i] = sc.nextInt();
        }
        long maxArea = 0;
        Set<String> set = new HashSet<>();
        for (int i = 0; i < n; i++) {
            set.add(x[i] + " " + y[i]);
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (x[i] == x[j] || y[i] == y[j]) continue;
                if (set.contains(x[i] + " " + y[j]) && set.contains(x[j] + " " + y[i])) {
                    long area = Math.abs((long)(x[i]-x[j]) * (long)(y[i]-y[j]));
                    maxArea = Math.max(maxArea, area);
                }
            }
        }
        System.out.println(maxArea);
    }
}
```
</details>

---
<h1 align="center"> C. Одержимый </h1>  
<h3 align="center">ограничение по времени на тест 1.5 секунда</h3>  
<h3 align="center">ограничение по памяти на тест 256 мегабайт  </h3>  
<h3 align="center">ввод: стандартный ввод</h3>  
<h3 align="center">вывод: стандартный вывод  </h3>
 

Игнат просто одержим интересными подотрезками массивов из целых неотрицательных чисел. Интересным подотрезком массива [a1,…,aN] он называет массив [al,al+1,…,ar−1,ar] (1 ≤ l ≤ r ≤ N), в котором не более одного нулевого элемента, а сумма всех элементов не превосходит числа K. У Игната есть массив a длины N . Найдите количество интересных подотрезков этого массива. 

**Входные данные**  
* В первой строке содержатся целые числа N и K (1 ≤ N ≤ 10^5; 0 ≤ K ≤ 10^9).
* Во второй строке содержатся целые числа a(1) , ..., a(N) (0 ≤ ai ≤ 10^9). 

**Выходные данные**  
Выведите количество интересных подотрезков массива.

**Система оценки**  
В этой задаче 4 группы тестов.

* Первая группа тестов стоит 3 балла, для нее выполняются ограничения N ≤ 100; 0 ≤ ai ≤ 10^5.
*Вторая группа тестов стоит 3 балла, для нее выполняются ограничения N ≤ 2000; 0 ≤ ai ≤10^9.
* Третья группа тестов стоит 2 балла, для нее выполняются ограничения N ≤ 10^5; 1 ≤ ai ≤ 10^9.
* Четвертая группа тестов стоит 2 балла, для нее выполняются ограничения N ≤ 10^5; 0 ≤ ai ≤ 10^9.

Входные данные
```
4 1
0 1 1 0
```
Выходные данные
```
6
```

Входные данные
```
4 4
1 2 3 4
```
Выходные данные
```
5
```

_Примечание:_  
В первом примере интересными являются четыре одноэлементных подотрезка, а также подотрезки [0,1] и [1,0].  
Во втором примере интересными являются четыре одноэлементных подотрезка, а также подотрезок [1,2].

<details>
  <summary>Решение на Java</summary>

```java
import java.util.Scanner;
    
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        long ans = 0;
        int l = 0;
        int r = 0;
        int sum = 0;
        int zeroCount = 0;
        while (r < n) {
            sum += a[r];
            if (a[r] == 0) {
                zeroCount++;
            }
            while (sum > k || zeroCount > 1) {
                sum -= a[l];
                if (a[l] == 0) {
                    zeroCount--;
                }
                l++;
            }
            ans += r - l + 1;
            r++;
        }
        System.out.println(ans);
    }
}
```
</details>

---
<h1 align="center"> D. Общительный человек </h1>  
<h3 align="center">ограничение по времени на тест 2 секунды</h3>  
<h3 align="center">ограничение по памяти на тест 256 мегабайт  </h3>  
<h3 align="center">ввод: стандартный ввод</h3>  
<h3 align="center">вывод: стандартный вывод  </h3>
 

Игнат позиционирует себя как общительный человек, поэтому у него много друзей. Недавно Игнат и его друзья придумали новый способ генерации случайных чисел. Способ заключается в том, что каждый из N друзей Игната берет кубик и записывает на всех его гранях какие-то целые числа (не обязательно различные). После этого все друзья одновременно кидают свои кубики, а Игнат складывает все выпавшие на кубиках числа. Получившаяся сумма и будет случайным сгенерированным числом.Игнату интересно, сколько различных целых чисел он может получить таким способом.

**Входные данные**  
В первой строке содержится целое число N — количество друзей Игната (3≤N≤100).
В i-й из следующих N строк содержатся целые числа ai1,ai2,ai3,ai4,ai5,ai6 — числа, записанные на гранях кубика i-го друга (0≤aij≤500).

**Выходные данные**  
Выведите количество различных целых чисел, которые могут быть получены с помощью описанного способа генерации случайных чисел.
Система оценки

**Система оценки**  
В этой задаче 3 группы тестов.

* Первая группа тестов стоит 4 балла, для нее выполняется ограничение N=3.  
* Вторая группа тестов стоит 3 балла, для нее выполняется ограничение N≤9.  
* Третья группа тестов стоит 3 балла, для нее выполняется ограничение N≤100.  

Входные данные
```
3
0 1 2 3 4 5
0 0 2 3 4 5
3 4 5 0 0 0
```
Выходные данные
```
16
```

_Примечание:_  
В примере описанным способом можно получить любое целое число от 0 до 15 включительно.

<details>
  <summary>Решение на C#</summary>

```C#
using System;
using System.Collections.Generic;
    
class Program
{
    static void Main()
    {
        int n = Convert.ToInt32(Console.ReadLine());
        bool[] possibleSums = new bool[n * 500 + 1];
        possibleSums[0] = true;
        for (int i = 0; i < n; i++)
        {
            string[] input = Console.ReadLine().Split();
            bool[] tempSums = new bool[n * 500 + 1];
            for (int j = 0; j < 6; j++)
            {
                int faceValue = Convert.ToInt32(input[j]);
                for (int k = 0; k < possibleSums.Length; k++)
                {
                    if (possibleSums[k])
                    {
                        tempSums[k + faceValue] = true;
                    }
                }
            }
            possibleSums = tempSums;
        }
        int count = 0;
        for (int i = 0; i < possibleSums.Length; i++)
        {
            if (possibleSums[i])
            {
                count++;
            }
        }
        Console.WriteLine(count);
    }
}
```
</details>

---
<h1 align="center"> E. Неплохой огородник </h1>  
<h3 align="center">ограничение по времени на тест 2 секунды</h3>  
<h3 align="center">ограничение по памяти на тест 256 мегабайт  </h3>  
<h3 align="center">ввод: стандартный ввод</h3>  
<h3 align="center">вывод: стандартный вывод  </h3>
 

В деревне у Игната есть огород. План огорода представляет из себя клеточное поле из N строк и M столбцов. Строки нумеруются от 1 до N сверху вниз, а столбцы нумеруются от 1 до M слева направо. Игнат на время уезжал в город, и за время его отсутствия огород зарос сорняками. Теперь огород можно описать матрицей N на M из целых неотрицательных чисел, обозначающих высоту сорняков в текущей клетке. Игнат хочет привести огород в порядок. Но так как он человек занятой, у него хватит времени только на то, чтобы прополоть ровно одну строку и ровно один столбец на плане огорода. После того как Игнат пропалывает одну клетку, высота сорняков в этой клетке становится равной нулю. Игнат ввел понятие запущенности огорода. Так он называет максимальную высоту сорняков среди всех клеток огорода. 

Теперь Игнат хочет выбрать строку и столбец, которые нужно прополоть, чтобы запущенность огорода стала как можно меньше. Найдите такие строку и столбец.

**Входные данные**  
В первой строке содержатся целые числа N и M (2≤N,M≤1400). В каждой из следующих N строк содержатся по M цифр от '0' до '9' без пробелов — высоты сорняков в соответствующих клетках огорода.

**Выходные данные**  
Выведите номер строки и номер столбца, которые нужно прополоть, чтобы запущенность огорода стала минимально возможной. Если подходящих ответов несколько, выведите любой из них.

**Система оценки**  
В этой задаче 3 группы тестов.
* Первая группа тестов стоит 4 балла, для нее выполняется ограничение N≤30.
* Вторая группа тестов стоит 3 балла, для нее выполняется ограничение N≤300.
* Третья группа тестов стоит 3 балла, для нее выполняется ограничение N≤1400.

Входные данные:  
```
5 4
4412
3212
0121
2192
4103
```
Выходные данные:  
```
1 3
```

_Примечание :_   
В примере есть несколько способов добиться минимальной запущенности огорода (она равна 4 ).  
Например, другой способ, кроме приведённого в примере — прополоть четвёртую строку и первый столбец. Любой ответ, приводящий к запущенности 4, является правильным.

> Данный код выполняет только 1 группу тестов и не выполняет остальную группу проверок! Одна из возможных оптимизаций - что-то придумать с функцией GetWeediness, которая выполняется за O(N*M), что является очень медленным, но решения которое бы не ломало логику я не придумал ¯\_(ツ)_/¯

<details>
  <summary>Решение на C++</summary>

```C++
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int GetWeediness(int** matrix, int n, int m, int iToClear, int jToClear) {
    int maxWeediness = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i != iToClear && j != jToClear) {
                maxWeediness = max(maxWeediness, matrix[i][j]);
            }
        }
    }
    return maxWeediness;
}

int main() {
    int n, m;
    cin >> n >> m;

    int** matrix = new int*[n];
    for (int i = 0; i < n; i++) {
        matrix[i] = new int[m];
        string line;
        cin >> line;
        for (int j = 0; j < m; j++) {
            matrix[i][j] = line[j] - '0';
        }
    }

    int minWeediness = INT_MAX;
    int minI = -1, minJ = -1;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            int currentWeediness = GetWeediness(matrix, n, m, i, j);
            if (currentWeediness < minWeediness) {
                minWeediness = currentWeediness;
                minI = i + 1;
                minJ = j + 1;
            }
        }
    }

    cout << minI << " " << minJ << endl;

    for (int i = 0; i < n; i++) {
        delete[] matrix[i];
    }
    delete[] matrix;

    return 0;
}
```
</details>